### Introduction

Book my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently). So we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.

### Ways to handling concurrent booking requests

When handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.

#### DB Locking

Once the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.

![Seat_Booking.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png?auto=compress,format&format=webp)

To maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by **true**) in our table.

**Algorithm**

*   User U1 initiates the booking, we set the start time to _T1_ and end time to _T3_(T1+10)
*   User U2 trying to access the same temporarily booked seat between _T1_ and _T3_ will not be able to book a seat.
*   If booking by U1 is successful between _T1_ and _T3_, we will toggle booked flag to **true** to ensure final booking confirmation.

![BMS_DB.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png?auto=compress,format&format=webp)

#### Transaction Isolation Level

We can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize [Transactional Isolation levels](https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms) to lock the rows before we update them. We can use _Serializable_ which is the highest isolation level and guarantees safety from:

*   Dirty reads
*   Non-repeatable reads
*   Phantom reads

With above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.

**Algorithm**

*   We set Transaction level of DB to TRANSACTION_SERIALIZABLE
*   If some user requests for booking seats, Transactional Isolation level locks the rows before we update them.
*   Now, if another user has requested a booking of 2 seats _S1_, _S2_, we check if these seats are locked
*   We check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).
*   If the above condition is **true**, then only we allow booking (whole transaction) to proceed.
*   If the above condition is **false**, then the booking (whole transaction) is cancelled.

    public boolean makeBooking(Booking booking){
        List<Seat> seats = booking.getSeats();
        Integer seatIds[] = new Integer[seats.size()];
        int index = 0;
        for(Seat seat:seats){
            seatIds[index++] = seat.getSeatId();
        }

        Connection dbConnection = null;
        try{
            dbConnection = getDBConnection();
            dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);

            statement st = dbConnection.createStatement();
            String selectSQL = "SELECT * FROM Seat where showId = ? && seatId in (?) && isReserved=0";
            PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);
            preparedStatement.setInt(1,booking.getShow().getShowId());
            Array array = dbConnection.createArrayOf("INTEGER",seatIds);
            preparedStatement.setArray(2,array);
            // all the seats being checkout out by other users will be locked and so will not be part of resultSet
            ResultSet rs = preparedStatement.executeQuery();

            if(rs.next()){
                rs.last(); //checking the last row
                int rowCount = rs.getRow(); // count of rows which are not locked

                if(rowCount==seats.size()){ // if no seats are locked
                    //update Seat Table
                   // update Booking Table
                  dbConnection.commit();
                  return true;
                 }
            }
        }catch(SQLException e){
            dbConnection.rollback();
            System.out.println(e.getMessages());
        }
        return false;
    }

#### Synchronisation with distributed caching

In the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the _critical section_ of our ticket booking function.

Now, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.

    public boolean makeBooking(Booking booking){
        List<Seat> seats = booking.getSeats();
        Integer seatIds[] = new Integer[seats.size()];
        int index = 0;
        for(Seat seat:seats){
            seatIds[index++] = seat.getSeatId();
        }

        Connection dbConnection = null;
        try{
            dbConnection = getDBConnection();
            dbConnection.setTransactionIsolation();

            statement st = dbConnection.createStatement();
            String selectSQL = "SELECT * FROM Seat where showId = ? && seatId in (?) && isReserved=0";
            PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);
            preparedStatement.setInt(1,booking.getShow().getShowId());
            Array array = dbConnection.createArrayOf("INTEGER",seatIds);
            preparedStatement.setArray(2,array);
            // all the seats being checkout out by other users will be locked and so will not be part of resultSet
            ResultSet rs = preparedStatement.executeQuery();

            synchronized(this){ // if no seats are locked
                    //update Seat Table
                   // update Booking Table
                  dbConnection.commit();
                  return true;
             }catch(SQLException e){
                dbConnection.rollback();
                System.out.println(e.getMessages());
             }
             return false;
    }

The above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.

To tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in [EntryProcessor-Rate Limiting Algorithms](https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution)).

### Conclusion

Airlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)

Thankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system. Feel free to comment, follow for updates!

</div>

</div>

<div class="mb-5 flex w-full flex-row flex-wrap justify-center md:mb-0">[<span>concurrency</span>](/tag/concurrency?source=tags_bottom_blogs)[<span>Databases</span>](/tag/databases?source=tags_bottom_blogs)[<span>Design</span>](/tag/design?source=tags_bottom_blogs)</div>

</div>

</section>

</div>

<div class="absolute z-50 mt-4 hidden">

<div class="flex flex-row items-center rounded-lg border border-slate-300 bg-white p-4 text-slate-800 shadow-lg dark:border-white dark:bg-slate-800 dark:text-slate-300"><span class="mr-3 block">Share this</span>[](https://twitter.com/share?url=https%3A%2F%2Fcodeminion.hashnode.dev%2Fhow-does-bookmyshow-handle-concurrent-bookings&text=%20%40codeminion)[](http://www.reddit.com/submit?title=How%20does%20BookMyShow%20handle%20concurrent%20bookings&selftext=true&text=%20https%3A%2F%2Fcodeminion.hashnode.dev%2Fhow-does-bookmyshow-handle-concurrent-bookings)</div>

</div>

</article>

</main>

</div>

</div>

</div>

<script type="text/javascript">var SUPPORTS_PASSIVE = false; try { var opts = Object.defineProperty({}, 'passive', { get: function() { SUPPORTS_PASSIVE = true; } }); window.addEventListener("testPassive", null, opts); window.removeEventListener("testPassive", null, opts); } catch (e) {}</script> <script type="text/javascript">// Array.prototype.flat polyfill if (!Array.prototype.flat) { // eslint-disable-next-line no-extend-native Object.defineProperty(Array.prototype, 'flat', { configurable: true, writable: true, value() { // eslint-disable-next-line prefer-rest-params const depth = typeof arguments[0] === 'undefined' ? 1 : Number(arguments[0]) || 0; const result = []; const { forEach } = result; // eslint-disable-next-line no-var var flatDeep = function (arr, depth) { forEach.call(arr, (val) => { if (depth > 0 && Array.isArray(val)) { flatDeep(val, depth - 1); } else { result.push(val); } }); }; flatDeep(this, depth); return result; }, }); }</script> <script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":"{\"_id\":\"6252ca4275dccb6f3431f7d4\",\"partOfPublication\":true,\"author\":{\"_id\":\"6247fa554b4dde0dc0be6315\",\"name\":\"Subham Sanghai\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg\",\"username\":\"codeminion\",\"bio\":\"\u003cp\u003eSenior Backend Developer\u003c/p\u003e\\n\",\"socialMedia\":{\"website\":\"\",\"github\":\"https://github.com/sanghaisubham\",\"twitter\":\"\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/sanghaisubham/\"},\"isDeactivated\":false},\"bookmarkedIn\":[],\"publication\":{\"_id\":\"6247fb204b4dde0dc0be635c\",\"audioBlogEnabled\":false,\"audioBlogVoiceType\":\"male\",\"author\":{\"_id\":\"6247fa554b4dde0dc0be6315\",\"name\":\"Subham Sanghai\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg\",\"username\":\"codeminion\"},\"badgePageEnabled\":false,\"description\":\"\",\"domain\":\"\",\"domainStatus\":{},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeLogo\":\"\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"displayTitle\":\"\",\"favicon\":\"\",\"gaTrackingID\":\"\",\"hasBadges\":true,\"headerColor\":\"#103495\",\"hideMembersPage\":true,\"isTeam\":false,\"layout\":\"magazine\",\"menu\":[],\"metaHTML\":\"\",\"metaHTMLSanitized\":\"\",\"newsletterEnabled\":false,\"newsletterPageEnabled\":true,\"ogImage\":\"\",\"logo\":\"\",\"textSelectionSharerEnabled\":true,\"title\":\"CodeMinion\",\"urlPattern\":\"simple\",\"username\":\"codeminion\",\"viewCountVisible\":false,\"readTimeHidden\":false,\"links\":{\"twitter\":\"\",\"instagram\":\"https://instagram.com/sanghaisubham\",\"github\":\"https://github.com/sanghaisubham\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@codeminion\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/sanghaisubham/\",\"mastodon\":\"\"},\"numPosts\":9,\"sponsorship\":{\"content\":\"\",\"contentMarkdown\":\"\"},\"umamiWebsiteUUID\":\"0824af55-d1a7-4687-aef7-728c4b806538\",\"allowContributorEdits\":true},\"tags\":[{\"_id\":\"56744723958ef13879b95312\",\"slug\":\"concurrency\",\"name\":\"concurrency\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b950eb\",\"slug\":\"databases\",\"name\":\"Databases\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b94e89\",\"slug\":\"design\",\"name\":\"Design\",\"isActive\":true,\"isApproved\":true}],\"coAuthors\":[],\"responseCount\":2,\"replyCount\":0,\"contentMarkdown\":\"### Introduction\\n\\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\\n\\n### Ways to handling concurrent booking requests\\n\\nWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\\n\\n#### DB Locking\\n\\nOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\\n\\n\\n![Seat_Booking.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png)\\n\\nTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by **true**) in our table. \\n\\n**Algorithm**\\n- User U1 initiates the booking, we set the start time to *T1* and end time to *T3*(T1+10)\\n- User U2 trying to access the same temporarily booked seat between *T1* and *T3* will not be able to book a seat.\\n- If booking by U1 is successful between *T1* and *T3*, we will toggle booked flag to **true** to ensure final booking confirmation.\\n\\n\\n\\n![BMS_DB.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png)\\n \\n#### Transaction Isolation Level\\n\\nWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize [Transactional Isolation levels](https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms) to lock the rows before we update them.\\nWe can use *Serializable* which is the highest isolation level and guarantees safety from:\\n\\n- Dirty reads\\n- Non-repeatable reads\\n- Phantom reads\\n\\nWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\\n\\n**Algorithm**\\n\\n- We set Transaction level of DB to TRANSACTION_SERIALIZABLE\\n- If some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\\n- Now, if another user has requested a booking of 2 seats *S1*, *S2*, we check if these seats are locked\\n- We check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\\n- If the above condition is **true**, then only we allow booking (whole transaction) to proceed.\\n- If the above condition is **false**, then the booking (whole transaction) is cancelled.\\n\\n```\\npublic boolean makeBooking(Booking booking){\\n List\u003cSeat\u003e seats = booking.getSeats();\\n Integer seatIds[] = new Integer[seats.size()];\\n int index = 0;\\n for(Seat seat:seats){\\n seatIds[index++] = seat.getSeatId();\\n }\\n\\n Connection dbConnection = null;\\n try{\\n dbConnection = getDBConnection();\\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\\n\\n statement st = dbConnection.createStatement();\\n String selectSQL = \\\"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\\\";\\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(1,booking.getShow().getShowId());\\n Array array = dbConnection.createArrayOf(\\\"INTEGER\\\",seatIds);\\n preparedStatement.setArray(2,array);\\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\\n ResultSet rs = preparedStatement.executeQuery();\\n\\n if(rs.next()){\\n rs.last(); //checking the last row\\n int rowCount = rs.getRow(); // count of rows which are not locked\\n\\n if(rowCount==seats.size()){ // if no seats are locked\\n //update Seat Table\\n // update Booking Table\\n dbConnection.commit();\\n return true;\\n }\\n }\\n }catch(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n return false;\\n}\\n``` \\n\\n#### Synchronisation with distributed caching \\n\\nIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the *critical section* of our ticket booking function.\\n\\nNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\\n\\n```\\npublic boolean makeBooking(Booking booking){\\n List\u003cSeat\u003e seats = booking.getSeats();\\n Integer seatIds[] = new Integer[seats.size()];\\n int index = 0;\\n for(Seat seat:seats){\\n seatIds[index++] = seat.getSeatId();\\n }\\n\\n Connection dbConnection = null;\\n try{\\n dbConnection = getDBConnection();\\n dbConnection.setTransactionIsolation();\\n\\n statement st = dbConnection.createStatement();\\n String selectSQL = \\\"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\\\";\\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(1,booking.getShow().getShowId());\\n Array array = dbConnection.createArrayOf(\\\"INTEGER\\\",seatIds);\\n preparedStatement.setArray(2,array);\\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\\n ResultSet rs = preparedStatement.executeQuery();\\n\\n synchronized(this){ // if no seats are locked\\n //update Seat Table\\n // update Booking Table\\n dbConnection.commit();\\n return true;\\n }catch(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n return false;\\n}\\n``` \\nThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\\n\\nTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in [EntryProcessor-Rate Limiting Algorithms](https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution)).\\n\\n### Conclusion\\n\\nAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\\n \\nThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\\nFeel free to comment, follow for updates!\",\"content\":\"\u003ch3 id=\\\"heading-introduction\\\"\u003eIntroduction\u003c/h3\u003e\\n\u003cp\u003eBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-ways-to-handling-concurrent-booking-requests\\\"\u003eWays to handling concurrent booking requests\u003c/h3\u003e\\n\u003cp\u003eWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\u003c/p\u003e\\n\u003ch4 id=\\\"heading-db-locking\\\"\u003eDB Locking\u003c/h4\u003e\\n\u003cp\u003eOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png\\\" alt=\\\"Seat_Booking.png\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by \u003cstrong\u003etrue\u003c/strong\u003e) in our table. \u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eUser U1 initiates the booking, we set the start time to \u003cem\u003eT1\u003c/em\u003e and end time to \u003cem\u003eT3\u003c/em\u003e(T1+10)\u003c/li\u003e\\n\u003cli\u003eUser U2 trying to access the same temporarily booked seat between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e will not be able to book a seat.\u003c/li\u003e\\n\u003cli\u003eIf booking by U1 is successful between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e, we will toggle booked flag to \u003cstrong\u003etrue\u003c/strong\u003e to ensure final booking confirmation.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png\\\" alt=\\\"BMS_DB.png\\\" /\u003e\u003c/p\u003e\\n\u003ch4 id=\\\"heading-transaction-isolation-level\\\"\u003eTransaction Isolation Level\u003c/h4\u003e\\n\u003cp\u003eWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize \u003ca target=\\\"_blank\\\" href=\\\"https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms\\\"\u003eTransactional Isolation levels\u003c/a\u003e to lock the rows before we update them.\\nWe can use \u003cem\u003eSerializable\u003c/em\u003e which is the highest isolation level and guarantees safety from:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eDirty reads\u003c/li\u003e\\n\u003cli\u003eNon-repeatable reads\u003c/li\u003e\\n\u003cli\u003ePhantom reads\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eWe set Transaction level of DB to TRANSACTION_SERIALIZABLE\u003c/li\u003e\\n\u003cli\u003eIf some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\u003c/li\u003e\\n\u003cli\u003eNow, if another user has requested a booking of 2 seats \u003cem\u003eS1\u003c/em\u003e, \u003cem\u003eS2\u003c/em\u003e, we check if these seats are locked\u003c/li\u003e\\n\u003cli\u003eWe check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\u003c/li\u003e\\n\u003cli\u003eIf the above condition is \u003cstrong\u003etrue\u003c/strong\u003e, then only we allow booking (whole transaction) to proceed.\u003c/li\u003e\\n\u003cli\u003eIf the above condition is \u003cstrong\u003efalse\u003c/strong\u003e, then the booking (whole transaction) is cancelled.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\\n List\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e booking.getSeats();\\n Integer seatIds[] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003enew\u003c/span\u003e Integer[seats.size()];\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e index \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-number\\\"\u003e0\u003c/span\u003e;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e(Seat seat:seats){\\n seatIds[index\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e seat.getSeatId();\\n }\\n\\n Connection dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e null;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003etry\u003c/span\u003e{\\n dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e getDBConnection();\\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\\n\\n statement st \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createStatement();\\n String selectSQL \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\\\"\u003c/span\u003e;\\n PreparedStatement preparedStatement \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\\n Array array \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"INTEGER\\\"\u003c/span\u003e,seatIds);\\n preparedStatement.setArray(\u003cspan class=\\\"hljs-number\\\"\u003e2\u003c/span\u003e,array);\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\\n ResultSet rs \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\\n\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e(rs.next()){\\n rs.last(); \u003cspan class=\\\"hljs-comment\\\"\u003e//checking the last row\u003c/span\u003e\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e rowCount \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e rs.getRow(); \u003cspan class=\\\"hljs-comment\\\"\u003e// count of rows which are not locked\u003c/span\u003e\\n\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e(rowCount\u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003eseats.size()){ \u003cspan class=\\\"hljs-comment\\\"\u003e// if no seats are locked\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e//update Seat Table\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// update Booking Table\u003c/span\u003e\\n dbConnection.commit();\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e;\\n }\\n }\\n }\u003cspan class=\\\"hljs-keyword\\\"\u003ecatch\u003c/span\u003e(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003efalse\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\\\"heading-synchronisation-with-distributed-caching\\\"\u003eSynchronisation with distributed caching\u003c/h4\u003e\\n\u003cp\u003eIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the \u003cem\u003ecritical section\u003c/em\u003e of our ticket booking function.\u003c/p\u003e\\n\u003cp\u003eNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\\n List\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e booking.getSeats();\\n Integer seatIds[] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003enew\u003c/span\u003e Integer[seats.size()];\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e index \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-number\\\"\u003e0\u003c/span\u003e;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e(Seat seat:seats){\\n seatIds[index\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e seat.getSeatId();\\n }\\n\\n Connection dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e null;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003etry\u003c/span\u003e{\\n dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e getDBConnection();\\n dbConnection.setTransactionIsolation();\\n\\n statement st \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createStatement();\\n String selectSQL \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\\\"\u003c/span\u003e;\\n PreparedStatement preparedStatement \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\\n Array array \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"INTEGER\\\"\u003c/span\u003e,seatIds);\\n preparedStatement.setArray(\u003cspan class=\\\"hljs-number\\\"\u003e2\u003c/span\u003e,array);\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\\n ResultSet rs \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\\n\\n synchronized(\u003cspan class=\\\"hljs-built_in\\\"\u003ethis\u003c/span\u003e){ \u003cspan class=\\\"hljs-comment\\\"\u003e// if no seats are locked\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e//update Seat Table\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// update Booking Table\u003c/span\u003e\\n dbConnection.commit();\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e;\\n }\u003cspan class=\\\"hljs-keyword\\\"\u003ecatch\u003c/span\u003e(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003efalse\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\u003c/p\u003e\\n\u003cp\u003eTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in \u003ca target=\\\"_blank\\\" href=\\\"https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution\\\"\u003eEntryProcessor-Rate Limiting Algorithms\u003c/a\u003e).\u003c/p\u003e\\n\u003ch3 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h3\u003e\\n\u003cp\u003eAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\u003c/p\u003e\\n\u003cp\u003eThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\\nFeel free to comment, follow for updates!\u003c/p\u003e\\n\",\"cuid\":\"cl1t90qu8088nsvnvb3yz2hm5\",\"views\":6733,\"title\":\"How does BookMyShow handle concurrent bookings\",\"slug\":\"how-does-bookmyshow-handle-concurrent-bookings\",\"dateAdded\":\"2022-04-10T12:30:16.846Z\",\"dateUpdated\":\"2022-04-10T17:32:15.836Z\",\"type\":\"story\",\"coverImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649581944370/pAbeRvblO.webp\",\"isCoverImagePortrait\":false,\"isCoverAttributionHidden\":false,\"brief\":\"Introduction\\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime ...\",\"isFollowing\":false,\"totalReactions\":37,\"totalReactionsByCurrentUser\":0,\"series\":null,\"isPinnedToBlog\":false,\"readTime\":5,\"sB\":false,\"isAMA\":false,\"subtitle\":\"\",\"isPartOfSeries\":false,\"hasTags\":true,\"pendingPublicationApproval\":false,\"ogImage\":\"\",\"metaTitle\":\"\",\"metaDescription\":\"\",\"isRepublished\":false,\"autoPublishedFromRSS\":false,\"responses\":[],\"isFeatured\":false,\"hasLatex\":false,\"stickCoverToBottom\":false,\"hideBadges\":false,\"badges\":[],\"isDelisted\":false,\"audioUrls\":{},\"disableComments\":false,\"enableToc\":true,\"toc\":[[{\"id\":\"db2d7dc8-f32f-4ba0-9ae1-d54b662d9fe7\",\"level\":3,\"slug\":\"introduction\",\"title\":\"Introduction\",\"parentId\":null}],[{\"id\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\",\"level\":3,\"slug\":\"ways-to-handling-concurrent-booking-requests\",\"title\":\"Ways to handling concurrent booking requests\",\"parentId\":null}],[{\"id\":\"0d3cebad-89e5-482d-b2d4-ac7a417bb73b\",\"level\":4,\"slug\":\"db-locking\",\"title\":\"DB Locking\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"}],[{\"id\":\"a088c24e-fd10-4fc2-bbd7-d7573cceae13\",\"level\":4,\"slug\":\"transaction-isolation-level\",\"title\":\"Transaction Isolation Level\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"}],[{\"id\":\"0fd65868-3e2b-4b40-af84-29828d119030\",\"level\":4,\"slug\":\"synchronisation-with-distributed-caching\",\"title\":\"Synchronisation with distributed caching\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"}],[{\"id\":\"7695cfcf-88b2-4cf0-9d76-fd2b7d365fde\",\"level\":3,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":null}]],\"noIndex\":false}","publication":"{\"__typename\":\"Publication\",\"id\":\"6247fb204b4dde0dc0be635c\",\"url\":\"https://codeminion.hashnode.dev\",\"canonicalURL\":\"https://codeminion.hashnode.dev\",\"urlPattern\":\"SIMPLE\",\"title\":\"CodeMinion\",\"displayTitle\":null,\"hasBadges\":true,\"descriptionSEO\":\"\",\"about\":null,\"features\":{\"newsletter\":{\"isEnabled\":false},\"viewCount\":{\"isEnabled\":false},\"readTime\":{\"isEnabled\":true},\"audioBlog\":{\"isEnabled\":false,\"voiceType\":\"MALE\"},\"textSelectionSharer\":{\"isEnabled\":true},\"customCSS\":{\"isEnabled\":false,\"published\":null,\"draft\":null}},\"metaTags\":null,\"ogMetaData\":{\"image\":null},\"author\":{\"__typename\":\"User\",\"id\":\"6247fa554b4dde0dc0be6315\",\"name\":\"Subham Sanghai\",\"username\":\"codeminion\",\"profilePicture\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg\"},\"preferences\":{\"__typename\":\"Preferences\",\"logo\":null,\"darkMode\":{\"__typename\":\"DarkModePreferences\",\"logo\":null,\"enabled\":null},\"navbarItems\":[],\"enabledPages\":{\"__typename\":\"PagesPreferences\",\"badges\":true,\"newsletter\":false,\"members\":null},\"layout\":\"magazine\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false},\"favicon\":null,\"headerColor\":\"#103495\",\"integrations\":{\"fbPixelID\":null,\"fathomSiteID\":null,\"fathomCustomDomainEnabled\":null,\"fathomCustomDomain\":null,\"hotjarSiteID\":null,\"matomoSiteID\":null,\"matomoURL\":null,\"gaTrackingID\":null,\"plausibleAnalyticsEnabled\":null,\"wmPaymentPointer\":null,\"umamiWebsiteUUID\":\"0824af55-d1a7-4687-aef7-728c4b806538\"},\"imprintV2\":null,\"postsCount\":{\"totalDocuments\":9},\"isTeam\":false,\"links\":{\"twitter\":\"\",\"instagram\":\"https://instagram.com/sanghaisubham\",\"github\":\"https://github.com/sanghaisubham\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@codeminion\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/sanghaisubham/\",\"mastodon\":null},\"domainInfo\":{\"__typename\":\"DomainInfo\",\"hashnodeSubdomain\":\"codeminion\",\"domain\":null,\"wwwPrefixedDomain\":null},\"redirectionRules\":[],\"totalRecommendedPublications\":0,\"sponsorship\":{\"content\":null,\"stripe\":null},\"pro\":null,\"allowContributorEdits\":true,\"rssImport\":null,\"post\":{\"id\":\"6252ca4275dccb6f3431f7d4\",\"cuid\":\"cl1t90qu8088nsvnvb3yz2hm5\",\"title\":\"How does BookMyShow handle concurrent bookings\",\"subtitle\":\"\",\"slug\":\"how-does-bookmyshow-handle-concurrent-bookings\",\"brief\":\"Introduction\\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime ...\",\"featured\":false,\"publishedAt\":\"2022-04-10T12:30:16.846Z\",\"updatedAt\":\"2022-04-10T17:32:15.836Z\",\"author\":{\"__typename\":\"User\",\"id\":\"6247fa554b4dde0dc0be6315\",\"name\":\"Subham Sanghai\",\"username\":\"codeminion\",\"deactivated\":false,\"profilePicture\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg\",\"isPro\":false,\"bio\":{\"html\":\"\u003cp\u003eSenior Backend Developer\u003c/p\u003e\\n\"},\"socialMediaLinks\":{\"website\":\"\",\"github\":\"https://github.com/sanghaisubham\",\"twitter\":\"\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/sanghaisubham/\"}},\"coAuthors\":[],\"seo\":{\"title\":null,\"description\":null,\"shouldNotIndex\":false},\"coverImage\":{\"url\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649581944370/pAbeRvblO.webp\",\"isPortrait\":false,\"attribution\":null,\"isAttributionHidden\":false,\"photographer\":null},\"responseCount\":2,\"reactionCount\":37,\"replyCount\":0,\"content\":{\"html\":\"\u003ch3 id=\\\"heading-introduction\\\"\u003eIntroduction\u003c/h3\u003e\\n\u003cp\u003eBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-ways-to-handling-concurrent-booking-requests\\\"\u003eWays to handling concurrent booking requests\u003c/h3\u003e\\n\u003cp\u003eWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\u003c/p\u003e\\n\u003ch4 id=\\\"heading-db-locking\\\"\u003eDB Locking\u003c/h4\u003e\\n\u003cp\u003eOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png\\\" alt=\\\"Seat_Booking.png\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by \u003cstrong\u003etrue\u003c/strong\u003e) in our table. \u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eUser U1 initiates the booking, we set the start time to \u003cem\u003eT1\u003c/em\u003e and end time to \u003cem\u003eT3\u003c/em\u003e(T1+10)\u003c/li\u003e\\n\u003cli\u003eUser U2 trying to access the same temporarily booked seat between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e will not be able to book a seat.\u003c/li\u003e\\n\u003cli\u003eIf booking by U1 is successful between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e, we will toggle booked flag to \u003cstrong\u003etrue\u003c/strong\u003e to ensure final booking confirmation.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png\\\" alt=\\\"BMS_DB.png\\\" /\u003e\u003c/p\u003e\\n\u003ch4 id=\\\"heading-transaction-isolation-level\\\"\u003eTransaction Isolation Level\u003c/h4\u003e\\n\u003cp\u003eWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize \u003ca target=\\\"_blank\\\" href=\\\"https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms\\\"\u003eTransactional Isolation levels\u003c/a\u003e to lock the rows before we update them.\\nWe can use \u003cem\u003eSerializable\u003c/em\u003e which is the highest isolation level and guarantees safety from:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eDirty reads\u003c/li\u003e\\n\u003cli\u003eNon-repeatable reads\u003c/li\u003e\\n\u003cli\u003ePhantom reads\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eWe set Transaction level of DB to TRANSACTION_SERIALIZABLE\u003c/li\u003e\\n\u003cli\u003eIf some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\u003c/li\u003e\\n\u003cli\u003eNow, if another user has requested a booking of 2 seats \u003cem\u003eS1\u003c/em\u003e, \u003cem\u003eS2\u003c/em\u003e, we check if these seats are locked\u003c/li\u003e\\n\u003cli\u003eWe check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\u003c/li\u003e\\n\u003cli\u003eIf the above condition is \u003cstrong\u003etrue\u003c/strong\u003e, then only we allow booking (whole transaction) to proceed.\u003c/li\u003e\\n\u003cli\u003eIf the above condition is \u003cstrong\u003efalse\u003c/strong\u003e, then the booking (whole transaction) is cancelled.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\\n List\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e booking.getSeats();\\n Integer seatIds[] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003enew\u003c/span\u003e Integer[seats.size()];\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e index \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-number\\\"\u003e0\u003c/span\u003e;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e(Seat seat:seats){\\n seatIds[index\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e seat.getSeatId();\\n }\\n\\n Connection dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e null;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003etry\u003c/span\u003e{\\n dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e getDBConnection();\\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\\n\\n statement st \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createStatement();\\n String selectSQL \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\\\"\u003c/span\u003e;\\n PreparedStatement preparedStatement \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\\n Array array \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"INTEGER\\\"\u003c/span\u003e,seatIds);\\n preparedStatement.setArray(\u003cspan class=\\\"hljs-number\\\"\u003e2\u003c/span\u003e,array);\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\\n ResultSet rs \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\\n\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e(rs.next()){\\n rs.last(); \u003cspan class=\\\"hljs-comment\\\"\u003e//checking the last row\u003c/span\u003e\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e rowCount \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e rs.getRow(); \u003cspan class=\\\"hljs-comment\\\"\u003e// count of rows which are not locked\u003c/span\u003e\\n\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e(rowCount\u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003eseats.size()){ \u003cspan class=\\\"hljs-comment\\\"\u003e// if no seats are locked\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e//update Seat Table\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// update Booking Table\u003c/span\u003e\\n dbConnection.commit();\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e;\\n }\\n }\\n }\u003cspan class=\\\"hljs-keyword\\\"\u003ecatch\u003c/span\u003e(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003efalse\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\\\"heading-synchronisation-with-distributed-caching\\\"\u003eSynchronisation with distributed caching\u003c/h4\u003e\\n\u003cp\u003eIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the \u003cem\u003ecritical section\u003c/em\u003e of our ticket booking function.\u003c/p\u003e\\n\u003cp\u003eNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\\n List\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e booking.getSeats();\\n Integer seatIds[] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003enew\u003c/span\u003e Integer[seats.size()];\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e index \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-number\\\"\u003e0\u003c/span\u003e;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e(Seat seat:seats){\\n seatIds[index\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e seat.getSeatId();\\n }\\n\\n Connection dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e null;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003etry\u003c/span\u003e{\\n dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e getDBConnection();\\n dbConnection.setTransactionIsolation();\\n\\n statement st \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createStatement();\\n String selectSQL \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\\\"\u003c/span\u003e;\\n PreparedStatement preparedStatement \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\\n Array array \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"INTEGER\\\"\u003c/span\u003e,seatIds);\\n preparedStatement.setArray(\u003cspan class=\\\"hljs-number\\\"\u003e2\u003c/span\u003e,array);\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\\n ResultSet rs \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\\n\\n synchronized(\u003cspan class=\\\"hljs-built_in\\\"\u003ethis\u003c/span\u003e){ \u003cspan class=\\\"hljs-comment\\\"\u003e// if no seats are locked\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e//update Seat Table\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// update Booking Table\u003c/span\u003e\\n dbConnection.commit();\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e;\\n }\u003cspan class=\\\"hljs-keyword\\\"\u003ecatch\u003c/span\u003e(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003efalse\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\u003c/p\u003e\\n\u003cp\u003eTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in \u003ca target=\\\"_blank\\\" href=\\\"https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution\\\"\u003eEntryProcessor-Rate Limiting Algorithms\u003c/a\u003e).\u003c/p\u003e\\n\u003ch3 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h3\u003e\\n\u003cp\u003eAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\u003c/p\u003e\\n\u003cp\u003eThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\\nFeel free to comment, follow for updates!\u003c/p\u003e\\n\",\"markdown\":\"### Introduction\\n\\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\\n\\n### Ways to handling concurrent booking requests\\n\\nWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\\n\\n#### DB Locking\\n\\nOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\\n\\n\\n![Seat_Booking.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png)\\n\\nTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by **true**) in our table. \\n\\n**Algorithm**\\n- User U1 initiates the booking, we set the start time to *T1* and end time to *T3*(T1+10)\\n- User U2 trying to access the same temporarily booked seat between *T1* and *T3* will not be able to book a seat.\\n- If booking by U1 is successful between *T1* and *T3*, we will toggle booked flag to **true** to ensure final booking confirmation.\\n\\n\\n\\n![BMS_DB.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png)\\n \\n#### Transaction Isolation Level\\n\\nWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize [Transactional Isolation levels](https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms) to lock the rows before we update them.\\nWe can use *Serializable* which is the highest isolation level and guarantees safety from:\\n\\n- Dirty reads\\n- Non-repeatable reads\\n- Phantom reads\\n\\nWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\\n\\n**Algorithm**\\n\\n- We set Transaction level of DB to TRANSACTION_SERIALIZABLE\\n- If some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\\n- Now, if another user has requested a booking of 2 seats *S1*, *S2*, we check if these seats are locked\\n- We check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\\n- If the above condition is **true**, then only we allow booking (whole transaction) to proceed.\\n- If the above condition is **false**, then the booking (whole transaction) is cancelled.\\n\\n```\\npublic boolean makeBooking(Booking booking){\\n List\u003cSeat\u003e seats = booking.getSeats();\\n Integer seatIds[] = new Integer[seats.size()];\\n int index = 0;\\n for(Seat seat:seats){\\n seatIds[index++] = seat.getSeatId();\\n }\\n\\n Connection dbConnection = null;\\n try{\\n dbConnection = getDBConnection();\\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\\n\\n statement st = dbConnection.createStatement();\\n String selectSQL = \\\"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\\\";\\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(1,booking.getShow().getShowId());\\n Array array = dbConnection.createArrayOf(\\\"INTEGER\\\",seatIds);\\n preparedStatement.setArray(2,array);\\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\\n ResultSet rs = preparedStatement.executeQuery();\\n\\n if(rs.next()){\\n rs.last(); //checking the last row\\n int rowCount = rs.getRow(); // count of rows which are not locked\\n\\n if(rowCount==seats.size()){ // if no seats are locked\\n //update Seat Table\\n // update Booking Table\\n dbConnection.commit();\\n return true;\\n }\\n }\\n }catch(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n return false;\\n}\\n``` \\n\\n#### Synchronisation with distributed caching \\n\\nIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the *critical section* of our ticket booking function.\\n\\nNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\\n\\n```\\npublic boolean makeBooking(Booking booking){\\n List\u003cSeat\u003e seats = booking.getSeats();\\n Integer seatIds[] = new Integer[seats.size()];\\n int index = 0;\\n for(Seat seat:seats){\\n seatIds[index++] = seat.getSeatId();\\n }\\n\\n Connection dbConnection = null;\\n try{\\n dbConnection = getDBConnection();\\n dbConnection.setTransactionIsolation();\\n\\n statement st = dbConnection.createStatement();\\n String selectSQL = \\\"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\\\";\\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(1,booking.getShow().getShowId());\\n Array array = dbConnection.createArrayOf(\\\"INTEGER\\\",seatIds);\\n preparedStatement.setArray(2,array);\\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\\n ResultSet rs = preparedStatement.executeQuery();\\n\\n synchronized(this){ // if no seats are locked\\n //update Seat Table\\n // update Booking Table\\n dbConnection.commit();\\n return true;\\n }catch(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n return false;\\n}\\n``` \\nThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\\n\\nTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in [EntryProcessor-Rate Limiting Algorithms](https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution)).\\n\\n### Conclusion\\n\\nAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\\n \\nThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\\nFeel free to comment, follow for updates!\"},\"views\":6733,\"preferences\":{\"pinnedToBlog\":false,\"disableComments\":false,\"stickCoverToBottom\":false,\"isDelisted\":false},\"readTimeInMinutes\":5,\"series\":null,\"tags\":[{\"id\":\"56744723958ef13879b95312\",\"slug\":\"concurrency\",\"name\":\"concurrency\"},{\"id\":\"56744722958ef13879b950eb\",\"slug\":\"databases\",\"name\":\"Databases\"},{\"id\":\"56744722958ef13879b94e89\",\"slug\":\"design\",\"name\":\"Design\"}],\"ogMetaData\":{\"image\":null},\"canonicalUrl\":null,\"hasLatexInPost\":false,\"audioUrls\":null,\"isFollowed\":null,\"bookmarked\":false,\"features\":{\"tableOfContents\":{\"isEnabled\":true,\"items\":[{\"__typename\":\"TableOfContentsItem\",\"id\":\"db2d7dc8-f32f-4ba0-9ae1-d54b662d9fe7\",\"level\":3,\"slug\":\"introduction\",\"title\":\"Introduction\",\"parentId\":null},{\"__typename\":\"TableOfContentsItem\",\"id\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\",\"level\":3,\"slug\":\"ways-to-handling-concurrent-booking-requests\",\"title\":\"Ways to handling concurrent booking requests\",\"parentId\":null},{\"__typename\":\"TableOfContentsItem\",\"id\":\"0d3cebad-89e5-482d-b2d4-ac7a417bb73b\",\"level\":4,\"slug\":\"db-locking\",\"title\":\"DB Locking\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"a088c24e-fd10-4fc2-bbd7-d7573cceae13\",\"level\":4,\"slug\":\"transaction-isolation-level\",\"title\":\"Transaction Isolation Level\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"0fd65868-3e2b-4b40-af84-29828d119030\",\"level\":4,\"slug\":\"synchronisation-with-distributed-caching\",\"title\":\"Synchronisation with distributed caching\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"},{\"__typename\":\"TableOfContentsItem\",\"id\":\"7695cfcf-88b2-4cf0-9d76-fd2b7d365fde\",\"level\":3,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":null}]},\"badges\":{\"isEnabled\":true,\"items\":[]}},\"isAutoPublishedFromRSS\":false,\"authenticatedUserLikes\":{\"edges\":[]},\"isShadowBanned\":false,\"isAskMeAnything\":false},\"staticPage\":null}","totalUsersWhoLikedArticle":5,"integrations":{"fbPixelID":null,"fathomSiteID":null,"fathomCustomDomainEnabled":null,"fathomCustomDomain":null,"hotjarSiteID":null,"matomoSiteID":null,"matomoURL":null,"gaTrackingID":null,"plausibleAnalyticsEnabled":null,"domainURL":"codeminion.hashnode.dev"},"rootLayout":{"legacyPublicationJSON":"{\"_id\":\"6247fb204b4dde0dc0be635c\",\"audioBlogEnabled\":false,\"audioBlogVoiceType\":\"male\",\"author\":{\"_id\":\"6247fa554b4dde0dc0be6315\",\"name\":\"Subham Sanghai\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg\",\"username\":\"codeminion\"},\"badgePageEnabled\":false,\"description\":\"\",\"domain\":\"\",\"domainStatus\":{},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeLogo\":\"\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"displayTitle\":\"\",\"favicon\":\"\",\"gaTrackingID\":\"\",\"hasBadges\":true,\"headerColor\":\"#103495\",\"hideMembersPage\":true,\"isTeam\":false,\"layout\":\"magazine\",\"menu\":[],\"metaHTML\":\"\",\"metaHTMLSanitized\":\"\",\"newsletterEnabled\":false,\"newsletterPageEnabled\":true,\"ogImage\":\"\",\"logo\":\"\",\"textSelectionSharerEnabled\":true,\"title\":\"CodeMinion\",\"urlPattern\":\"simple\",\"username\":\"codeminion\",\"viewCountVisible\":false,\"readTimeHidden\":false,\"links\":{\"twitter\":\"\",\"instagram\":\"https://instagram.com/sanghaisubham\",\"github\":\"https://github.com/sanghaisubham\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@codeminion\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/sanghaisubham/\",\"mastodon\":\"\"},\"numPosts\":9,\"sponsorship\":{\"content\":\"\",\"contentMarkdown\":\"\"},\"umamiWebsiteUUID\":\"0824af55-d1a7-4687-aef7-728c4b806538\",\"allowContributorEdits\":true}","legacyPostJSON":"{\"_id\":\"6252ca4275dccb6f3431f7d4\",\"partOfPublication\":true,\"author\":{\"_id\":\"6247fa554b4dde0dc0be6315\",\"name\":\"Subham Sanghai\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg\",\"username\":\"codeminion\",\"bio\":\"\u003cp\u003eSenior Backend Developer\u003c/p\u003e\\n\",\"socialMedia\":{\"website\":\"\",\"github\":\"https://github.com/sanghaisubham\",\"twitter\":\"\",\"facebook\":\"\",\"stackoverflow\":\"\",\"linkedin\":\"https://www.linkedin.com/in/sanghaisubham/\"},\"isDeactivated\":false},\"bookmarkedIn\":[],\"publication\":{\"_id\":\"6247fb204b4dde0dc0be635c\",\"audioBlogEnabled\":false,\"audioBlogVoiceType\":\"male\",\"author\":{\"_id\":\"6247fa554b4dde0dc0be6315\",\"name\":\"Subham Sanghai\",\"photo\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg\",\"username\":\"codeminion\"},\"badgePageEnabled\":false,\"description\":\"\",\"domain\":\"\",\"domainStatus\":{},\"wwwPrefixedDomainStatus\":{},\"customCSSEnabled\":false,\"customCSSPublished\":{\"homeMin\":\"\",\"postMin\":\"\",\"staticMin\":\"\"},\"customRules\":[],\"darkModeLogo\":\"\",\"disableFooterBranding\":false,\"isSubscriptionModalDisabled\":false,\"displayTitle\":\"\",\"favicon\":\"\",\"gaTrackingID\":\"\",\"hasBadges\":true,\"headerColor\":\"#103495\",\"hideMembersPage\":true,\"isTeam\":false,\"layout\":\"magazine\",\"menu\":[],\"metaHTML\":\"\",\"metaHTMLSanitized\":\"\",\"newsletterEnabled\":false,\"newsletterPageEnabled\":true,\"ogImage\":\"\",\"logo\":\"\",\"textSelectionSharerEnabled\":true,\"title\":\"CodeMinion\",\"urlPattern\":\"simple\",\"username\":\"codeminion\",\"viewCountVisible\":false,\"readTimeHidden\":false,\"links\":{\"twitter\":\"\",\"instagram\":\"https://instagram.com/sanghaisubham\",\"github\":\"https://github.com/sanghaisubham\",\"website\":\"\",\"hashnode\":\"https://hashnode.com/@codeminion\",\"youtube\":\"\",\"dailydev\":\"\",\"linkedin\":\"https://www.linkedin.com/in/sanghaisubham/\",\"mastodon\":\"\"},\"numPosts\":9,\"sponsorship\":{\"content\":\"\",\"contentMarkdown\":\"\"},\"umamiWebsiteUUID\":\"0824af55-d1a7-4687-aef7-728c4b806538\",\"allowContributorEdits\":true},\"tags\":[{\"_id\":\"56744723958ef13879b95312\",\"slug\":\"concurrency\",\"name\":\"concurrency\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b950eb\",\"slug\":\"databases\",\"name\":\"Databases\",\"isActive\":true,\"isApproved\":true},{\"_id\":\"56744722958ef13879b94e89\",\"slug\":\"design\",\"name\":\"Design\",\"isActive\":true,\"isApproved\":true}],\"coAuthors\":[],\"responseCount\":2,\"replyCount\":0,\"contentMarkdown\":\"### Introduction\\n\\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\\n\\n### Ways to handling concurrent booking requests\\n\\nWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\\n\\n#### DB Locking\\n\\nOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\\n\\n\\n![Seat_Booking.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png)\\n\\nTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by **true**) in our table. \\n\\n**Algorithm**\\n- User U1 initiates the booking, we set the start time to *T1* and end time to *T3*(T1+10)\\n- User U2 trying to access the same temporarily booked seat between *T1* and *T3* will not be able to book a seat.\\n- If booking by U1 is successful between *T1* and *T3*, we will toggle booked flag to **true** to ensure final booking confirmation.\\n\\n\\n\\n![BMS_DB.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png)\\n \\n#### Transaction Isolation Level\\n\\nWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize [Transactional Isolation levels](https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms) to lock the rows before we update them.\\nWe can use *Serializable* which is the highest isolation level and guarantees safety from:\\n\\n- Dirty reads\\n- Non-repeatable reads\\n- Phantom reads\\n\\nWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\\n\\n**Algorithm**\\n\\n- We set Transaction level of DB to TRANSACTION_SERIALIZABLE\\n- If some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\\n- Now, if another user has requested a booking of 2 seats *S1*, *S2*, we check if these seats are locked\\n- We check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\\n- If the above condition is **true**, then only we allow booking (whole transaction) to proceed.\\n- If the above condition is **false**, then the booking (whole transaction) is cancelled.\\n\\n```\\npublic boolean makeBooking(Booking booking){\\n List\u003cSeat\u003e seats = booking.getSeats();\\n Integer seatIds[] = new Integer[seats.size()];\\n int index = 0;\\n for(Seat seat:seats){\\n seatIds[index++] = seat.getSeatId();\\n }\\n\\n Connection dbConnection = null;\\n try{\\n dbConnection = getDBConnection();\\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\\n\\n statement st = dbConnection.createStatement();\\n String selectSQL = \\\"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\\\";\\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(1,booking.getShow().getShowId());\\n Array array = dbConnection.createArrayOf(\\\"INTEGER\\\",seatIds);\\n preparedStatement.setArray(2,array);\\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\\n ResultSet rs = preparedStatement.executeQuery();\\n\\n if(rs.next()){\\n rs.last(); //checking the last row\\n int rowCount = rs.getRow(); // count of rows which are not locked\\n\\n if(rowCount==seats.size()){ // if no seats are locked\\n //update Seat Table\\n // update Booking Table\\n dbConnection.commit();\\n return true;\\n }\\n }\\n }catch(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n return false;\\n}\\n``` \\n\\n#### Synchronisation with distributed caching \\n\\nIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the *critical section* of our ticket booking function.\\n\\nNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\\n\\n```\\npublic boolean makeBooking(Booking booking){\\n List\u003cSeat\u003e seats = booking.getSeats();\\n Integer seatIds[] = new Integer[seats.size()];\\n int index = 0;\\n for(Seat seat:seats){\\n seatIds[index++] = seat.getSeatId();\\n }\\n\\n Connection dbConnection = null;\\n try{\\n dbConnection = getDBConnection();\\n dbConnection.setTransactionIsolation();\\n\\n statement st = dbConnection.createStatement();\\n String selectSQL = \\\"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\\\";\\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(1,booking.getShow().getShowId());\\n Array array = dbConnection.createArrayOf(\\\"INTEGER\\\",seatIds);\\n preparedStatement.setArray(2,array);\\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\\n ResultSet rs = preparedStatement.executeQuery();\\n\\n synchronized(this){ // if no seats are locked\\n //update Seat Table\\n // update Booking Table\\n dbConnection.commit();\\n return true;\\n }catch(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n return false;\\n}\\n``` \\nThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\\n\\nTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in [EntryProcessor-Rate Limiting Algorithms](https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution)).\\n\\n### Conclusion\\n\\nAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\\n \\nThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\\nFeel free to comment, follow for updates!\",\"content\":\"\u003ch3 id=\\\"heading-introduction\\\"\u003eIntroduction\u003c/h3\u003e\\n\u003cp\u003eBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\u003c/p\u003e\\n\u003ch3 id=\\\"heading-ways-to-handling-concurrent-booking-requests\\\"\u003eWays to handling concurrent booking requests\u003c/h3\u003e\\n\u003cp\u003eWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\u003c/p\u003e\\n\u003ch4 id=\\\"heading-db-locking\\\"\u003eDB Locking\u003c/h4\u003e\\n\u003cp\u003eOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\u003c/p\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png\\\" alt=\\\"Seat_Booking.png\\\" /\u003e\u003c/p\u003e\\n\u003cp\u003eTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by \u003cstrong\u003etrue\u003c/strong\u003e) in our table. \u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eUser U1 initiates the booking, we set the start time to \u003cem\u003eT1\u003c/em\u003e and end time to \u003cem\u003eT3\u003c/em\u003e(T1+10)\u003c/li\u003e\\n\u003cli\u003eUser U2 trying to access the same temporarily booked seat between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e will not be able to book a seat.\u003c/li\u003e\\n\u003cli\u003eIf booking by U1 is successful between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e, we will toggle booked flag to \u003cstrong\u003etrue\u003c/strong\u003e to ensure final booking confirmation.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e\u003cimg src=\\\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png\\\" alt=\\\"BMS_DB.png\\\" /\u003e\u003c/p\u003e\\n\u003ch4 id=\\\"heading-transaction-isolation-level\\\"\u003eTransaction Isolation Level\u003c/h4\u003e\\n\u003cp\u003eWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize \u003ca target=\\\"_blank\\\" href=\\\"https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms\\\"\u003eTransactional Isolation levels\u003c/a\u003e to lock the rows before we update them.\\nWe can use \u003cem\u003eSerializable\u003c/em\u003e which is the highest isolation level and guarantees safety from:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eDirty reads\u003c/li\u003e\\n\u003cli\u003eNon-repeatable reads\u003c/li\u003e\\n\u003cli\u003ePhantom reads\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003eWe set Transaction level of DB to TRANSACTION_SERIALIZABLE\u003c/li\u003e\\n\u003cli\u003eIf some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\u003c/li\u003e\\n\u003cli\u003eNow, if another user has requested a booking of 2 seats \u003cem\u003eS1\u003c/em\u003e, \u003cem\u003eS2\u003c/em\u003e, we check if these seats are locked\u003c/li\u003e\\n\u003cli\u003eWe check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\u003c/li\u003e\\n\u003cli\u003eIf the above condition is \u003cstrong\u003etrue\u003c/strong\u003e, then only we allow booking (whole transaction) to proceed.\u003c/li\u003e\\n\u003cli\u003eIf the above condition is \u003cstrong\u003efalse\u003c/strong\u003e, then the booking (whole transaction) is cancelled.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\\n List\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e booking.getSeats();\\n Integer seatIds[] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003enew\u003c/span\u003e Integer[seats.size()];\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e index \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-number\\\"\u003e0\u003c/span\u003e;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e(Seat seat:seats){\\n seatIds[index\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e seat.getSeatId();\\n }\\n\\n Connection dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e null;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003etry\u003c/span\u003e{\\n dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e getDBConnection();\\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\\n\\n statement st \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createStatement();\\n String selectSQL \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\\\"\u003c/span\u003e;\\n PreparedStatement preparedStatement \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\\n Array array \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"INTEGER\\\"\u003c/span\u003e,seatIds);\\n preparedStatement.setArray(\u003cspan class=\\\"hljs-number\\\"\u003e2\u003c/span\u003e,array);\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\\n ResultSet rs \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\\n\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e(rs.next()){\\n rs.last(); \u003cspan class=\\\"hljs-comment\\\"\u003e//checking the last row\u003c/span\u003e\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e rowCount \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e rs.getRow(); \u003cspan class=\\\"hljs-comment\\\"\u003e// count of rows which are not locked\u003c/span\u003e\\n\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eif\u003c/span\u003e(rowCount\u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003eseats.size()){ \u003cspan class=\\\"hljs-comment\\\"\u003e// if no seats are locked\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e//update Seat Table\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// update Booking Table\u003c/span\u003e\\n dbConnection.commit();\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e;\\n }\\n }\\n }\u003cspan class=\\\"hljs-keyword\\\"\u003ecatch\u003c/span\u003e(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003efalse\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\\\"heading-synchronisation-with-distributed-caching\\\"\u003eSynchronisation with distributed caching\u003c/h4\u003e\\n\u003cp\u003eIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the \u003cem\u003ecritical section\u003c/em\u003e of our ticket booking function.\u003c/p\u003e\\n\u003cp\u003eNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\u003c/p\u003e\\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\\\"hljs-keyword\\\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\\n List\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\\\"hljs-operator\\\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e booking.getSeats();\\n Integer seatIds[] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-keyword\\\"\u003enew\u003c/span\u003e Integer[seats.size()];\\n \u003cspan class=\\\"hljs-keyword\\\"\u003eint\u003c/span\u003e index \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-number\\\"\u003e0\u003c/span\u003e;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003efor\u003c/span\u003e(Seat seat:seats){\\n seatIds[index\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e\u003cspan class=\\\"hljs-operator\\\"\u003e+\u003c/span\u003e] \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e seat.getSeatId();\\n }\\n\\n Connection dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e null;\\n \u003cspan class=\\\"hljs-keyword\\\"\u003etry\u003c/span\u003e{\\n dbConnection \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e getDBConnection();\\n dbConnection.setTransactionIsolation();\\n\\n statement st \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createStatement();\\n String selectSQL \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e \u003cspan class=\\\"hljs-string\\\"\u003e\\\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\\\"\u003c/span\u003e;\\n PreparedStatement preparedStatement \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\\n preparedStatement.setInt(\u003cspan class=\\\"hljs-number\\\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\\n Array array \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\\\"hljs-string\\\"\u003e\\\"INTEGER\\\"\u003c/span\u003e,seatIds);\\n preparedStatement.setArray(\u003cspan class=\\\"hljs-number\\\"\u003e2\u003c/span\u003e,array);\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\\n ResultSet rs \u003cspan class=\\\"hljs-operator\\\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\\n\\n synchronized(\u003cspan class=\\\"hljs-built_in\\\"\u003ethis\u003c/span\u003e){ \u003cspan class=\\\"hljs-comment\\\"\u003e// if no seats are locked\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e//update Seat Table\u003c/span\u003e\\n \u003cspan class=\\\"hljs-comment\\\"\u003e// update Booking Table\u003c/span\u003e\\n dbConnection.commit();\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003etrue\u003c/span\u003e;\\n }\u003cspan class=\\\"hljs-keyword\\\"\u003ecatch\u003c/span\u003e(SQLException e){\\n dbConnection.rollback();\\n System.out.println(e.getMessages());\\n }\\n \u003cspan class=\\\"hljs-keyword\\\"\u003ereturn\u003c/span\u003e \u003cspan class=\\\"hljs-literal\\\"\u003efalse\u003c/span\u003e;\\n}\\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\u003c/p\u003e\\n\u003cp\u003eTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in \u003ca target=\\\"_blank\\\" href=\\\"https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution\\\"\u003eEntryProcessor-Rate Limiting Algorithms\u003c/a\u003e).\u003c/p\u003e\\n\u003ch3 id=\\\"heading-conclusion\\\"\u003eConclusion\u003c/h3\u003e\\n\u003cp\u003eAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\u003c/p\u003e\\n\u003cp\u003eThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\\nFeel free to comment, follow for updates!\u003c/p\u003e\\n\",\"cuid\":\"cl1t90qu8088nsvnvb3yz2hm5\",\"views\":6733,\"title\":\"How does BookMyShow handle concurrent bookings\",\"slug\":\"how-does-bookmyshow-handle-concurrent-bookings\",\"dateAdded\":\"2022-04-10T12:30:16.846Z\",\"dateUpdated\":\"2022-04-10T17:32:15.836Z\",\"type\":\"story\",\"coverImage\":\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649581944370/pAbeRvblO.webp\",\"isCoverImagePortrait\":false,\"isCoverAttributionHidden\":false,\"brief\":\"Introduction\\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime ...\",\"isFollowing\":false,\"totalReactions\":37,\"totalReactionsByCurrentUser\":0,\"series\":null,\"isPinnedToBlog\":false,\"readTime\":5,\"sB\":false,\"isAMA\":false,\"subtitle\":\"\",\"isPartOfSeries\":false,\"hasTags\":true,\"pendingPublicationApproval\":false,\"ogImage\":\"\",\"metaTitle\":\"\",\"metaDescription\":\"\",\"isRepublished\":false,\"autoPublishedFromRSS\":false,\"responses\":[],\"isFeatured\":false,\"hasLatex\":false,\"stickCoverToBottom\":false,\"hideBadges\":false,\"badges\":[],\"isDelisted\":false,\"audioUrls\":{},\"disableComments\":false,\"enableToc\":true,\"toc\":[[{\"id\":\"db2d7dc8-f32f-4ba0-9ae1-d54b662d9fe7\",\"level\":3,\"slug\":\"introduction\",\"title\":\"Introduction\",\"parentId\":null}],[{\"id\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\",\"level\":3,\"slug\":\"ways-to-handling-concurrent-booking-requests\",\"title\":\"Ways to handling concurrent booking requests\",\"parentId\":null}],[{\"id\":\"0d3cebad-89e5-482d-b2d4-ac7a417bb73b\",\"level\":4,\"slug\":\"db-locking\",\"title\":\"DB Locking\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"}],[{\"id\":\"a088c24e-fd10-4fc2-bbd7-d7573cceae13\",\"level\":4,\"slug\":\"transaction-isolation-level\",\"title\":\"Transaction Isolation Level\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"}],[{\"id\":\"0fd65868-3e2b-4b40-af84-29828d119030\",\"level\":4,\"slug\":\"synchronisation-with-distributed-caching\",\"title\":\"Synchronisation with distributed caching\",\"parentId\":\"363d2c1b-a7d9-4c49-a141-92d2b18af4a8\"}],[{\"id\":\"7695cfcf-88b2-4cf0-9d76-fd2b7d365fde\",\"level\":3,\"slug\":\"conclusion\",\"title\":\"Conclusion\",\"parentId\":null}]],\"noIndex\":false}","legacySeriesJSON":null,"headProps":{"title":"How does BookMyShow handle concurrent bookings","description":"Introduction\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime ...","author":{"name":"Subham Sanghai","username":"codeminion"},"links":[{"rel":"canonical","href":"https://codeminion.hashnode.dev/how-does-bookmyshow-handle-concurrent-bookings"}],"pageType":"article","bannerType":"large","ogSiteName":"CodeMinion","url":"https://codeminion.hashnode.dev/how-does-bookmyshow-handle-concurrent-bookings","ogImage":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1649581944370%2FpAbeRvblO.webp%3Fw%3D1200%26h%3D630%26fit%3Dcrop%26crop%3Dentropy%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng","twitterImage":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1649581944370%2FpAbeRvblO.webp%3Fw%3D1200%26h%3D630%26fit%3Dcrop%26crop%3Dentropy%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng","twitterHandle":"","monetization":null,"style":{},"customHeadItems":{"customFavicon":null,"customTheme":"#103495","customMeta":null},"hljs":true},"isDarkTheme":false,"headerColor":"#103495","isBadge":null,"isRecommendations":null,"isHome":null,"currentMenuId":null,"hnmcMode":false,"postCUID":"cl1t90qu8088nsvnvb3yz2hm5","seoSchema":{"@context":"https://schema.org","@type":"NewsArticle","url":"https://codeminion.hashnode.dev/how-does-bookmyshow-handle-concurrent-bookings","mainEntityOfPage":"https://codeminion.hashnode.dev/how-does-bookmyshow-handle-concurrent-bookings","headline":"How does BookMyShow handle concurrent bookings","description":"Introduction\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime ...","datePublished":"2022-04-10T12:30:16.846Z","dateModified":"2022-04-10T17:32:15.836Z","isAccessibleForFree":true,"author":{"@type":"Person","name":"Subham Sanghai","url":"https://hashnode.com/@codeminion"},"publisher":{"@type":"Organization","name":"CodeMinion","url":"https://codeminion.hashnode.dev","logo":"https://hashnode.com/utility/r?url=https%3A%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1559814205701%2Fek9fO-yT0.jpeg%3Fw%3D800%26bm%3Dnormal%26balph%3D100%26txt64%3DQ29kZU1pbmlvbg%26txtsize%3D42%26txtfit%3Dmax%26txtalign%3Dmiddle%2Ccenter%26txtfont%3DHelvetica%20Neue%2CBold%26txtclr%3Dffffff%26blend%3D103495"},"image":{"@type":"ImageObject","url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1649581944370/pAbeRvblO.webp"}},"publication":{"__typename":"Publication","id":"6247fb204b4dde0dc0be635c","url":"https://codeminion.hashnode.dev","canonicalURL":"https://codeminion.hashnode.dev","urlPattern":"SIMPLE","title":"CodeMinion","displayTitle":null,"hasBadges":true,"descriptionSEO":"","about":null,"features":{"newsletter":{"isEnabled":false},"viewCount":{"isEnabled":false},"readTime":{"isEnabled":true},"audioBlog":{"isEnabled":false,"voiceType":"MALE"},"textSelectionSharer":{"isEnabled":true},"customCSS":{"isEnabled":false,"published":null,"draft":null}},"metaTags":null,"ogMetaData":{"image":null},"author":{"__typename":"User","id":"6247fa554b4dde0dc0be6315","name":"Subham Sanghai","username":"codeminion","profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg"},"preferences":{"__typename":"Preferences","logo":null,"darkMode":{"__typename":"DarkModePreferences","logo":null,"enabled":null},"navbarItems":[],"enabledPages":{"__typename":"PagesPreferences","badges":true,"newsletter":false,"members":null},"layout":"magazine","disableFooterBranding":false,"isSubscriptionModalDisabled":false},"favicon":null,"headerColor":"#103495","integrations":{"fbPixelID":null,"fathomSiteID":null,"fathomCustomDomainEnabled":null,"fathomCustomDomain":null,"hotjarSiteID":null,"matomoSiteID":null,"matomoURL":null,"gaTrackingID":null,"plausibleAnalyticsEnabled":null},"imprintV2":null,"postsCount":{"totalDocuments":9},"isTeam":false,"links":{"twitter":"","instagram":"https://instagram.com/sanghaisubham","github":"https://github.com/sanghaisubham","website":"","hashnode":"https://hashnode.com/@codeminion","youtube":"","dailydev":"","linkedin":"https://www.linkedin.com/in/sanghaisubham/","mastodon":null},"domainInfo":{"__typename":"DomainInfo","hashnodeSubdomain":"codeminion","domain":null,"wwwPrefixedDomain":null},"redirectionRules":[],"totalRecommendedPublications":0,"sponsorship":{"content":null,"stripe":null},"pro":null,"allowContributorEdits":true,"rssImport":null,"post":{"id":"6252ca4275dccb6f3431f7d4","cuid":"cl1t90qu8088nsvnvb3yz2hm5","title":"How does BookMyShow handle concurrent bookings","subtitle":"","slug":"how-does-bookmyshow-handle-concurrent-bookings","brief":"Introduction\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime ...","featured":false,"publishedAt":"2022-04-10T12:30:16.846Z","updatedAt":"2022-04-10T17:32:15.836Z","author":{"__typename":"User","id":"6247fa554b4dde0dc0be6315","name":"Subham Sanghai","username":"codeminion","deactivated":false,"profilePicture":"https://cdn.hashnode.com/res/hashnode/image/upload/v1648884310529/efl1-asu_.jpeg","isPro":false,"bio":{"html":"\u003cp\u003eSenior Backend Developer\u003c/p\u003e\n"},"socialMediaLinks":{"website":"","github":"https://github.com/sanghaisubham","twitter":"","facebook":"","stackoverflow":"","linkedin":"https://www.linkedin.com/in/sanghaisubham/"}},"coAuthors":[],"seo":{"title":null,"description":null,"shouldNotIndex":false},"coverImage":{"url":"https://cdn.hashnode.com/res/hashnode/image/upload/v1649581944370/pAbeRvblO.webp","isPortrait":false,"attribution":null,"isAttributionHidden":false,"photographer":null},"responseCount":2,"reactionCount":37,"replyCount":0,"content":{"html":"\u003ch3 id=\"heading-introduction\"\u003eIntroduction\u003c/h3\u003e\n\u003cp\u003eBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\u003c/p\u003e\n\u003ch3 id=\"heading-ways-to-handling-concurrent-booking-requests\"\u003eWays to handling concurrent booking requests\u003c/h3\u003e\n\u003cp\u003eWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\u003c/p\u003e\n\u003ch4 id=\"heading-db-locking\"\u003eDB Locking\u003c/h4\u003e\n\u003cp\u003eOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png\" alt=\"Seat_Booking.png\" /\u003e\u003c/p\u003e\n\u003cp\u003eTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by \u003cstrong\u003etrue\u003c/strong\u003e) in our table. \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUser U1 initiates the booking, we set the start time to \u003cem\u003eT1\u003c/em\u003e and end time to \u003cem\u003eT3\u003c/em\u003e(T1+10)\u003c/li\u003e\n\u003cli\u003eUser U2 trying to access the same temporarily booked seat between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e will not be able to book a seat.\u003c/li\u003e\n\u003cli\u003eIf booking by U1 is successful between \u003cem\u003eT1\u003c/em\u003e and \u003cem\u003eT3\u003c/em\u003e, we will toggle booked flag to \u003cstrong\u003etrue\u003c/strong\u003e to ensure final booking confirmation.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png\" alt=\"BMS_DB.png\" /\u003e\u003c/p\u003e\n\u003ch4 id=\"heading-transaction-isolation-level\"\u003eTransaction Isolation Level\u003c/h4\u003e\n\u003cp\u003eWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize \u003ca target=\"_blank\" href=\"https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms\"\u003eTransactional Isolation levels\u003c/a\u003e to lock the rows before we update them.\nWe can use \u003cem\u003eSerializable\u003c/em\u003e which is the highest isolation level and guarantees safety from:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDirty reads\u003c/li\u003e\n\u003cli\u003eNon-repeatable reads\u003c/li\u003e\n\u003cli\u003ePhantom reads\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAlgorithm\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe set Transaction level of DB to TRANSACTION_SERIALIZABLE\u003c/li\u003e\n\u003cli\u003eIf some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\u003c/li\u003e\n\u003cli\u003eNow, if another user has requested a booking of 2 seats \u003cem\u003eS1\u003c/em\u003e, \u003cem\u003eS2\u003c/em\u003e, we check if these seats are locked\u003c/li\u003e\n\u003cli\u003eWe check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\u003c/li\u003e\n\u003cli\u003eIf the above condition is \u003cstrong\u003etrue\u003c/strong\u003e, then only we allow booking (whole transaction) to proceed.\u003c/li\u003e\n\u003cli\u003eIf the above condition is \u003cstrong\u003efalse\u003c/strong\u003e, then the booking (whole transaction) is cancelled.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\n List\u003cspan class=\"hljs-operator\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e booking.getSeats();\n Integer seatIds[] \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Integer[seats.size()];\n \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(Seat seat:seats){\n seatIds[index\u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e] \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e seat.getSeatId();\n }\n\n Connection dbConnection \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e null;\n \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e{\n dbConnection \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e getDBConnection();\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n\n statement st \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e dbConnection.createStatement();\n String selectSQL \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\"\u003c/span\u003e;\n PreparedStatement preparedStatement \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\n preparedStatement.setInt(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\n Array array \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\"hljs-string\"\u003e\"INTEGER\"\u003c/span\u003e,seatIds);\n preparedStatement.setArray(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,array);\n \u003cspan class=\"hljs-comment\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\n ResultSet rs \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(rs.next()){\n rs.last(); \u003cspan class=\"hljs-comment\"\u003e//checking the last row\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e rowCount \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e rs.getRow(); \u003cspan class=\"hljs-comment\"\u003e// count of rows which are not locked\u003c/span\u003e\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(rowCount\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003eseats.size()){ \u003cspan class=\"hljs-comment\"\u003e// if no seats are locked\u003c/span\u003e\n \u003cspan class=\"hljs-comment\"\u003e//update Seat Table\u003c/span\u003e\n \u003cspan class=\"hljs-comment\"\u003e// update Booking Table\u003c/span\u003e\n dbConnection.commit();\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n }\n }\n }\u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(SQLException e){\n dbConnection.rollback();\n System.out.println(e.getMessages());\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"heading-synchronisation-with-distributed-caching\"\u003eSynchronisation with distributed caching\u003c/h4\u003e\n\u003cp\u003eIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the \u003cem\u003ecritical section\u003c/em\u003e of our ticket booking function.\u003c/p\u003e\n\u003cp\u003eNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e boolean makeBooking(Booking booking){\n List\u003cspan class=\"hljs-operator\"\u003e\u0026lt;\u003c/span\u003eSeat\u003cspan class=\"hljs-operator\"\u003e\u0026gt;\u003c/span\u003e seats \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e booking.getSeats();\n Integer seatIds[] \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Integer[seats.size()];\n \u003cspan class=\"hljs-keyword\"\u003eint\u003c/span\u003e index \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(Seat seat:seats){\n seatIds[index\u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e+\u003c/span\u003e] \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e seat.getSeatId();\n }\n\n Connection dbConnection \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e null;\n \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e{\n dbConnection \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e getDBConnection();\n dbConnection.setTransactionIsolation();\n\n statement st \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e dbConnection.createStatement();\n String selectSQL \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM Seat where showId = ? \u0026amp;\u0026amp; seatId in (?) \u0026amp;\u0026amp; isReserved=0\"\u003c/span\u003e;\n PreparedStatement preparedStatement \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e dbConnection.prepareStatement(selectSQL);\n preparedStatement.setInt(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,booking.getShow().getShowId());\n Array array \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e dbConnection.createArrayOf(\u003cspan class=\"hljs-string\"\u003e\"INTEGER\"\u003c/span\u003e,seatIds);\n preparedStatement.setArray(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,array);\n \u003cspan class=\"hljs-comment\"\u003e// all the seats being checkout out by other users will be locked and so will not be part of resultSet\u003c/span\u003e\n ResultSet rs \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e preparedStatement.executeQuery();\n\n synchronized(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e){ \u003cspan class=\"hljs-comment\"\u003e// if no seats are locked\u003c/span\u003e\n \u003cspan class=\"hljs-comment\"\u003e//update Seat Table\u003c/span\u003e\n \u003cspan class=\"hljs-comment\"\u003e// update Booking Table\u003c/span\u003e\n dbConnection.commit();\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n }\u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(SQLException e){\n dbConnection.rollback();\n System.out.println(e.getMessages());\n }\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\u003c/p\u003e\n\u003cp\u003eTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in \u003ca target=\"_blank\" href=\"https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution\"\u003eEntryProcessor-Rate Limiting Algorithms\u003c/a\u003e).\u003c/p\u003e\n\u003ch3 id=\"heading-conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\u003c/p\u003e\n\u003cp\u003eThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\nFeel free to comment, follow for updates!\u003c/p\u003e\n","markdown":"### Introduction\n\nBook my show is a ticket booking application which helps users in booking single/multiple seats for a movie/show/event etc. in a particular geographical location. It is possible that multiple users try to book the same show and sometime same seat at the same time (concurrently).\nSo we need to design a system that can handle such concurrent requests, so that no two person has confirmation of same seat booking.\n\n### Ways to handling concurrent booking requests\n\nWhen handling such concurrent requests, there are multiple approaches to solve the concurrency issue and provide a great user experience. We would be seeing some of the mostly used approaches not only in book my show but other ticket booking applications too.\n\n#### DB Locking\n\nOnce the user selects the available seat, application locks the seat temporarily for the next 10 minutes. The application interact with the DB and block the seat for the user. The ticket will be booked temporarily for the current user and for all the other users the seat will be unavailable for the next 10 minutes. If the user fails to book the ticket within that timeframe the seat will be released for the other users. This should be done on a first come first serve basis.\n\n\n![Seat_Booking.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649595959237/bSxe3ZX9B.png)\n\nTo maintain/lock a row in DB, we need to add a timeslot(starttime and endtime) columns and isReserved flag(successful booking can be denoted by **true**) in our table. \n\n**Algorithm**\n- User U1 initiates the booking, we set the start time to *T1* and end time to *T3*(T1+10)\n- User U2 trying to access the same temporarily booked seat between *T1* and *T3* will not be able to book a seat.\n- If booking by U1 is successful between *T1* and *T3*, we will toggle booked flag to **true** to ensure final booking confirmation.\n\n\n\n![BMS_DB.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1649611868223/_gjuOyjVk.png)\n \n#### Transaction Isolation Level\n\nWe can use transactions in SQL database to avoid any clashes. In SQL servers, we can utilize [Transactional Isolation levels](https://radhikanarang.hashnode.dev/transaction-isolation-levels-in-dbms) to lock the rows before we update them.\nWe can use *Serializable* which is the highest isolation level and guarantees safety from:\n\n- Dirty reads\n- Non-repeatable reads\n- Phantom reads\n\nWith above database transaction, we can safely assume that the reservation will be marked successfully and no two customers(users) will be able to reserve the same seat.\n\n**Algorithm**\n\n- We set Transaction level of DB to TRANSACTION_SERIALIZABLE\n- If some user requests for booking seats, Transactional Isolation level locks the rows before we update them.\n- Now, if another user has requested a booking of 2 seats *S1*, *S2*, we check if these seats are locked\n- We check, if the count of unlocked/available seats among the requested seats is equal to the number of seat booking requested by user (here 2).\n- If the above condition is **true**, then only we allow booking (whole transaction) to proceed.\n- If the above condition is **false**, then the booking (whole transaction) is cancelled.\n\n```\npublic boolean makeBooking(Booking booking){\n List\u003cSeat\u003e seats = booking.getSeats();\n Integer seatIds[] = new Integer[seats.size()];\n int index = 0;\n for(Seat seat:seats){\n seatIds[index++] = seat.getSeatId();\n }\n\n Connection dbConnection = null;\n try{\n dbConnection = getDBConnection();\n dbConnection.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n\n statement st = dbConnection.createStatement();\n String selectSQL = \"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\";\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\n preparedStatement.setInt(1,booking.getShow().getShowId());\n Array array = dbConnection.createArrayOf(\"INTEGER\",seatIds);\n preparedStatement.setArray(2,array);\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\n ResultSet rs = preparedStatement.executeQuery();\n\n if(rs.next()){\n rs.last(); //checking the last row\n int rowCount = rs.getRow(); // count of rows which are not locked\n\n if(rowCount==seats.size()){ // if no seats are locked\n //update Seat Table\n // update Booking Table\n dbConnection.commit();\n return true;\n }\n }\n }catch(SQLException e){\n dbConnection.rollback();\n System.out.println(e.getMessages());\n }\n return false;\n}\n``` \n\n#### Synchronisation with distributed caching \n\nIn the above code, if we notice the actual booking logic, is when the system gets the booking requests and tries to update the DB with the booking details. So, we can consider this code block to be the *critical section* of our ticket booking function.\n\nNow, if we can restrict only one process(thread) to access the critical section, we would be able to handle concurrent(parallel) requests successfully. To do the same, we can use a synchronised block that locks the critical section allowing only one thread to execute the code inside this section.\n\n```\npublic boolean makeBooking(Booking booking){\n List\u003cSeat\u003e seats = booking.getSeats();\n Integer seatIds[] = new Integer[seats.size()];\n int index = 0;\n for(Seat seat:seats){\n seatIds[index++] = seat.getSeatId();\n }\n\n Connection dbConnection = null;\n try{\n dbConnection = getDBConnection();\n dbConnection.setTransactionIsolation();\n\n statement st = dbConnection.createStatement();\n String selectSQL = \"SELECT * FROM Seat where showId = ? \u0026\u0026 seatId in (?) \u0026\u0026 isReserved=0\";\n PreparedStatement preparedStatement = dbConnection.prepareStatement(selectSQL);\n preparedStatement.setInt(1,booking.getShow().getShowId());\n Array array = dbConnection.createArrayOf(\"INTEGER\",seatIds);\n preparedStatement.setArray(2,array);\n // all the seats being checkout out by other users will be locked and so will not be part of resultSet\n ResultSet rs = preparedStatement.executeQuery();\n\n synchronized(this){ // if no seats are locked\n //update Seat Table\n // update Booking Table\n dbConnection.commit();\n return true;\n }catch(SQLException e){\n dbConnection.rollback();\n System.out.println(e.getMessages());\n }\n return false;\n}\n``` \nThe above synchronisation, works fine when we have only one instance(one JVM), but this would not work in case we have multiple instances(multiple JVM's) because a synchronisation block wouldn't provide access control to a shared resource within one JVM, but not across JVM's.\n\nTo tackle the same in distributed systems, we need to use a distributed cache like Redis or HazelCast that can read and update the value in one atomic operation. In hazelcast we can do the same using EntryProcessor(similar to what we did in [EntryProcessor-Rate Limiting Algorithms](https://codeminion.hashnode.dev/rate-limiting-algorithms#heading-solution)).\n\n### Conclusion\n\nAirlines/Trains also use similar algorithms and does a tentative allocation of the seat to the first user that expires after some length of time (e.g., 10 minutes for kiosks) that gives him enough time to pay. If the (customer-visible) transaction fails through or times out, the seat allocation can be released back into the pool. (All state changes are processed via the transactional database, and one customer-visible transaction might require many database-level transactions.)\n \nThankyou for your time, I hope this article helped in understanding, how book my show or other similar ticket booking application deals with concurrent booking requests in their system.\nFeel free to comment, follow for updates!"},"views":6733,"preferences":{"pinnedToBlog":false,"disableComments":false,"stickCoverToBottom":false,"isDelisted":false},"readTimeInMinutes":5,"series":null,"tags":[{"id":"56744723958ef13879b95312","slug":"concurrency","name":"concurrency"},{"id":"56744722958ef13879b950eb","slug":"databases","name":"Databases"},{"id":"56744722958ef13879b94e89","slug":"design","name":"Design"}],"ogMetaData":{"image":null},"canonicalUrl":null,"hasLatexInPost":false,"audioUrls":null,"isFollowed":null,"bookmarked":false,"features":{"tableOfContents":{"isEnabled":true,"items":[{"__typename":"TableOfContentsItem","id":"db2d7dc8-f32f-4ba0-9ae1-d54b662d9fe7","level":3,"slug":"introduction","title":"Introduction","parentId":null},{"__typename":"TableOfContentsItem","id":"363d2c1b-a7d9-4c49-a141-92d2b18af4a8","level":3,"slug":"ways-to-handling-concurrent-booking-requests","title":"Ways to handling concurrent booking requests","parentId":null},{"__typename":"TableOfContentsItem","id":"0d3cebad-89e5-482d-b2d4-ac7a417bb73b","level":4,"slug":"db-locking","title":"DB Locking","parentId":"363d2c1b-a7d9-4c49-a141-92d2b18af4a8"},{"__typename":"TableOfContentsItem","id":"a088c24e-fd10-4fc2-bbd7-d7573cceae13","level":4,"slug":"transaction-isolation-level","title":"Transaction Isolation Level","parentId":"363d2c1b-a7d9-4c49-a141-92d2b18af4a8"},{"__typename":"TableOfContentsItem","id":"0fd65868-3e2b-4b40-af84-29828d119030","level":4,"slug":"synchronisation-with-distributed-caching","title":"Synchronisation with distributed caching","parentId":"363d2c1b-a7d9-4c49-a141-92d2b18af4a8"},{"__typename":"TableOfContentsItem","id":"7695cfcf-88b2-4cf0-9d76-fd2b7d365fde","level":3,"slug":"conclusion","title":"Conclusion","parentId":null}]},"badges":{"isEnabled":true,"items":[]}},"isAutoPublishedFromRSS":false,"authenticatedUserLikes":{"edges":[]},"isShadowBanned":false,"isAskMeAnything":false},"staticPage":null},"series":null}},"__N_SSP":true},"page":"/[...slug]","query":{"slug":["how-does-bookmyshow-handle-concurrent-bookings"]},"buildId":"-bTytSs9ArRkcLTUFtvR_","isFallback":false,"dynamicIds":[40331],"gssp":true,"scriptLoader":[]}</script>